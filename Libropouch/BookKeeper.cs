using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Resources;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace Libropouch
{
    static class BookKeeper
    {
        public static void Add(String file) //Add a new book into the library
        {
            var finfo = new FileInfo(file);
            var supportedExtensions = Properties.Settings.Default.FileExtensions.Split(';');

            if (!supportedExtensions.Contains(finfo.Extension.Substring(1), StringComparer.CurrentCultureIgnoreCase))
                //Only allow files with supported extensions
                return;

            var dirName = finfo.Name.Substring(0, (finfo.Name.Length - finfo.Extension.Length));
                //Dir to store all book related files in, name derived from the file name
            var dirPath = Properties.Settings.Default.FilesDir + "/" + dirName;

            Directory.CreateDirectory(dirPath); //Create the dir in the default book folder, specified in the settings

            if (!Directory.Exists(dirPath) || 1 == 1)
            {

                finfo.CopyTo(dirPath + "/" + finfo.Name, true);

                var bookInfo = new BookPeek(finfo);

                foreach (var l in bookInfo.List)
                {
                    Debug.WriteLine(l);
                }

                //Debug.WriteLine(bookInfo.List["Author"]);

                //Debug.WriteLine(finfo.Name.Substring(0, (finfo.Name.Length - finfo.Extension.Length)));
            }
        }
    }

    class BookPeek //Extract book info from ebook files
    {
        public Dictionary<string, object> List = new Dictionary<string, object>();

        public BookPeek(FileInfo file)
        {
            if(file.Extension.ToLower() == ".mobi")
                Mobi(file);
        }         

        private void Mobi(FileInfo file)
        {
            //Processing MOBI header            
            var types = new Dictionary<UInt32, String>
                {
                    {2, "Mobipocket Book"},
                    {3, "PalmDoc Book"},
                    {4, "Audio"},
                    {232, "mobipocket? generated by kindlegen1.2"},
                    {248, "KF8: generated by kindlegen2"},
                    {257, "News"},
                    {258, "News Feed"},
                    {259, "News Magazine"},
                    {513, "Pics"},
                    {514, "Word"},
                    {515, "XLS"},
                    {516, "PPT"},
                    {517, "Text"},
                    {518, "HTML"}                    
                };

            using (var fs = File.OpenRead(@file.FullName))
            {                
                var headerIdent = new byte[4];
                var headerFound = false;
                var headerLength = new byte[4];
                var type = new byte[4];
                var title = new byte[4];
                var titleOffset = new byte[4];
                var titleLength = new byte[4];
                var exthFlags = new byte[4];
                long headerPos = 0;

                fs.Seek(300, SeekOrigin.Current);

                while (fs.Read(headerIdent, 0, headerIdent.Length) > 0)
                {
                    if (Encoding.UTF8.GetBytes("MOBI").SequenceEqual(headerIdent))
                    {
                        headerPos = fs.Position;
                        headerFound = true;
                        break;
                    }
                }

                Debug.WriteLine("Header position: " + fs.Position);

                if (!headerFound)
                {
                    MainWindow.Info(string.Format("{0} is missing the MOBI header and therefore I am not able to extract any information from it.", file.Name));
                    return;
                }

                fs.Read(headerLength, 0, headerLength.Length);
                    fs.Read(type, 0, type.Length);

                    if (types.ContainsKey(ByteToUInt32(type)))
                        List.Add("Type", types[ByteToUInt32(type)]);

                    fs.Seek((14*4), SeekOrigin.Current); //Skip some next fields
                    fs.Read(titleOffset, 0, titleOffset.Length);
                    fs.Read(titleLength, 0, titleLength.Length);
                    fs.Seek((9 * 4), SeekOrigin.Current); //Skip some next fields
                    fs.Read(exthFlags, 0, exthFlags.Length);                    
                //Process the EXTH header
                if ((ByteToUInt32(exthFlags) & 0x40) != 0)
                    MobiExth(fs, file);

                if (List.ContainsKey("Title")) //If exth contained the book title, no need to continue
                    return;

                //Get book title from the mobi header, the title itself is located after the exth header, if any
                fs.Seek(headerPos + ByteToUInt32(titleOffset) - 4 - 16, SeekOrigin.Begin); 
                var b = new byte[ByteToUInt32(titleLength)];
                fs.Read(b, 0, b.Length);                

                if (ByteToUInt32(titleLength) > 0)
                {
                    List.Add("Title", Encoding.UTF8.GetString(b).Replace("\0", String.Empty));
                    Debug.WriteLine(Encoding.UTF8.GetString(b).Replace("\0", String.Empty));
                }
                else
                    List.Add("Title", file.Name);
            }
        }

        private void MobiExth(FileStream fs, FileInfo file)
        {
            var records = new Dictionary<UInt32, string>();
            var headerIdent = new byte[4];
            var headerLength = new byte[4];
            var recordCount = new byte[4];

            while (fs.Read(headerIdent, 0, headerIdent.Length) > 0)
            {
                if (Encoding.UTF8.GetBytes("EXTH").SequenceEqual(headerIdent))
                    break;
            }

            if (fs.Length == fs.Position)
            {
                MainWindow.Info(String.Format("{0} is missing EXTH header and therefore I wasn't able to extract any extra information from it.", file.Name), 1);
                return;
            }

            fs.Read(headerLength, 0, headerLength.Length);
            fs.Read(recordCount, 0, recordCount.Length);

            try
            {
                for (var i = 0; i < ByteToUInt32(recordCount); i++)
                {
                    var recordType = new byte[4];
                    var recordLength = new byte[4];

                    fs.Read(recordType, 0, recordType.Length);
                    fs.Read(recordLength, 0, recordLength.Length);

                    //Debug.WriteLine(ByteToUInt32(recordType));
                    var recordData = new byte[ByteToUInt32(recordLength) - 8];
                    fs.Read(recordData, 0, recordData.Length);

                    records.Add(ByteToUInt32(recordType), Encoding.UTF8.GetString(recordData).Replace("\0", String.Empty));
                }

                if (records.ContainsKey(100))
                    List.Add("Author", records[100]);

                if (records.ContainsKey(503))
                    List.Add("Title", records[503]);

                if (records.ContainsKey(101))
                    List.Add("Publisher", records[101]);

                if (records.ContainsKey(524))
                    List.Add("Language", records[524]);

                if (records.ContainsKey(106))
                    List.Add("Published", DateTime.Parse(records[106]));
            }
            catch (Exception e)
            {
                MainWindow.Info(String.Format("Something is wrong with EXTH header in {0}: {1}", file.Name, e), 1);
            }  
        }

        private static UInt32 ByteToUInt32(byte[] bytesToConvert)
        {
            //Make copy so we're not permanently reversing the order of the bytes in the actual field
            var buffer = (byte[])bytesToConvert.Clone();

            if (BitConverter.IsLittleEndian)
                Array.Reverse(buffer);

            return BitConverter.ToUInt32(buffer, 0); 
        }
    }
        
    
}
