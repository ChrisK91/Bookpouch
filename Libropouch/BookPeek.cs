using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using System.Xml.Linq;

namespace Libropouch
{
    class BookPeek //Extract book info from ebook files
    {
        public Dictionary<string, object> List = new Dictionary<string, object>();

        public BookPeek(FileInfo file)
        {
            if (file.Extension.ToLower() == ".mobi")
                Mobi(file);
            else if (file.Extension.ToLower() == ".epub")
                Epub(file);

            if(!List.ContainsKey("title"))
                List.Add("title", file.Name.Substring(0, (file.Name.Length - file.Extension.Length)));
        }

        private void Epub(FileSystemInfo file)
        {

            try
            {          
                using (var zip = ZipFile.Open(file.FullName, ZipArchiveMode.Read))
                {   
                    //Get location of the content file 
                    var container = zip.GetEntry("META-INF/container.xml");
                    var containerXml = XDocument.Load(container.Open());
                
                    XNamespace ns = containerXml.Root.Attribute("xmlns").Value;

                    var rootFile = containerXml
                        .Root
                        .Descendants(ns + "rootfile")
                        .FirstOrDefault()
                        .Attribute("full-path")
                        .Value;

                    //Get book info from the content file
                    var content = zip.GetEntry(rootFile);
                    var contentXml = XDocument.Load(content.Open());                    
                    XNamespace contentNs = contentXml.Root.Attribute("xmlns").Value;
                    var customNs = XNamespace.Get("http://purl.org/dc/elements/1.1/");                    
                    var metaData = contentXml.Root.Descendants(contentNs + "metadata").FirstOrDefault();
                    
                    var meta = from el in metaData.Descendants() where el.Name.Namespace == customNs select el;

                    var author = metaData.Descendants(customNs + "creator").FirstOrDefault();
                    var title = metaData.Descendants(customNs + "title").FirstOrDefault();
                    var publisher = metaData.Descendants(customNs + "publisher").FirstOrDefault();
                    var language = metaData.Descendants(customNs + "language").FirstOrDefault();
                    var published = metaData.Descendants(customNs + "date").FirstOrDefault();                                       

                    if (author != null)
                        List.Add("author", author.Value);

                    if (title != null)
                        List.Add("title", title.Value);

                    if (publisher != null)
                        List.Add("publisher", publisher.Value);

                    if (language != null)
                        List.Add("language", language.Value);

                    if (published != null)
                        List.Add("published", DateTime.Parse(published.Value));
                }
            }
            catch (Exception)
            {
                MainWindow.Info("I wasn't ale to get any information from the Epub file, it may be corrupted or is missing some key files.", 1);
            }             
        }        

        private void Mobi(FileSystemInfo file)
        {
            //Processing MOBI header            
            var types = new Dictionary<UInt32, String>
                {
                    {2, "Mobipocket Book"},
                    {3, "PalmDoc Book"},
                    {4, "Audio"},
                    {232, "mobipocket? generated by kindlegen1.2"},
                    {248, "KF8: generated by kindlegen2"},
                    {257, "News"},
                    {258, "News Feed"},
                    {259, "News Magazine"},
                    {513, "Pics"},
                    {514, "Word"},
                    {515, "XLS"},
                    {516, "PPT"},
                    {517, "Text"},
                    {518, "HTML"}                    
                };

            using (var fs = File.OpenRead(@file.FullName))
            {
                var headerIdent = new byte[4];
                var headerFound = false;
                var headerLength = new byte[4];
                var type = new byte[4];
                var title = new byte[4];
                var titleOffset = new byte[4];
                var titleLength = new byte[4];
                var exthFlags = new byte[4];
                long headerPos = 0;

                fs.Seek(300, SeekOrigin.Current);

                while (fs.Read(headerIdent, 0, headerIdent.Length) > 0)
                {
                    if (Encoding.UTF8.GetBytes("MOBI").SequenceEqual(headerIdent))
                    {
                        headerPos = fs.Position;
                        headerFound = true;
                        break;
                    }
                }

                Debug.WriteLine("Header position: " + fs.Position);

                if (!headerFound)
                {
                    MainWindow.Info(string.Format("{0} is missing the MOBI header and therefore I am not able to extract any information from it.", file.Name));
                    return;
                }

                fs.Read(headerLength, 0, headerLength.Length);
                fs.Read(type, 0, type.Length);

                if (types.ContainsKey(ByteToUInt32(type)))
                    List.Add("type", types[ByteToUInt32(type)]);

                fs.Seek((14 * 4), SeekOrigin.Current); //Skip some next fields
                fs.Read(titleOffset, 0, titleOffset.Length);
                fs.Read(titleLength, 0, titleLength.Length);
                fs.Seek((9 * 4), SeekOrigin.Current); //Skip some next fields
                fs.Read(exthFlags, 0, exthFlags.Length);
                //Process the EXTH header
                if ((ByteToUInt32(exthFlags) & 0x40) != 0)
                    MobiExth(fs, file);

                if (List.ContainsKey("title")) //If exth contained the book title, no need to continue
                    return;

                //Get book title from the mobi header, the title itself is located after the exth header, if any
                fs.Seek(headerPos + ByteToUInt32(titleOffset) - 4 - 16, SeekOrigin.Begin);
                var b = new byte[ByteToUInt32(titleLength)];
                fs.Read(b, 0, b.Length);

                if (ByteToUInt32(titleLength) > 0)
                {
                    List.Add("title", Encoding.UTF8.GetString(b).Replace("\0", String.Empty));
                    Debug.WriteLine(Encoding.UTF8.GetString(b).Replace("\0", String.Empty));
                }    
            }
        }

        private void MobiExth(Stream fs, FileSystemInfo file)
        {
            var records = new Dictionary<UInt32, string>();
            var headerIdent = new byte[4];
            var headerLength = new byte[4];
            var recordCount = new byte[4];

            while (fs.Read(headerIdent, 0, headerIdent.Length) > 0)
            {
                if (Encoding.UTF8.GetBytes("EXTH").SequenceEqual(headerIdent))
                    break;
            }

            if (fs.Length == fs.Position)
            {
                MainWindow.Info(String.Format("{0} is missing EXTH header and therefore I wasn't able to extract any extra information from it.", file.Name), 1);
                return;
            }

            fs.Read(headerLength, 0, headerLength.Length);
            fs.Read(recordCount, 0, recordCount.Length);

            try
            {
                for (var i = 0; i < ByteToUInt32(recordCount); i++)
                {
                    var recordType = new byte[4];
                    var recordLength = new byte[4];

                    fs.Read(recordType, 0, recordType.Length);
                    fs.Read(recordLength, 0, recordLength.Length);

                    //Debug.WriteLine(ByteToUInt32(recordType));
                    var recordData = new byte[ByteToUInt32(recordLength) - 8];
                    fs.Read(recordData, 0, recordData.Length);

                    records.Add(ByteToUInt32(recordType), Encoding.UTF8.GetString(recordData).Replace("\0", String.Empty));
                }

                if (records.ContainsKey(100))
                    List.Add("author", records[100]);

                if (records.ContainsKey(503))
                    List.Add("title", records[503]);

                if (records.ContainsKey(101))
                    List.Add("publisher", records[101]);

                if (records.ContainsKey(524))
                    List.Add("language", records[524]);

                if (records.ContainsKey(106))
                    List.Add("published", DateTime.Parse(records[106]));
            }
            catch (Exception e)
            {
                MainWindow.Info(String.Format("Something is wrong with EXTH header in {0}: {1}", file.Name, e), 1);
            }
        }

        private static UInt32 ByteToUInt32(byte[] bytesToConvert)
        {
            //Make copy so we're not permanently reversing the order of the bytes in the actual field
            var buffer = (byte[])bytesToConvert.Clone();

            if (BitConverter.IsLittleEndian)
                Array.Reverse(buffer);

            return BitConverter.ToUInt32(buffer, 0);
        }
    }
        
}
